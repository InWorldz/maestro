#!/usr/bin/env python
# Copyright (c) 2006-2007 XenSource, Inc.
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import os
import sys
import cmd
import code
import pprint
import shlex
import string
import readline

import maestro.rpcclient
import maestro.version

from optparse import OptionParser

DEBUG = 0
TESTRUN = 0
PROFILE = 0

class Shell(cmd.Cmd):
    def __init__(self, session):
        cmd.Cmd.__init__(self)
        self.session = session
        self.identchars = string.ascii_letters + string.digits + '_.'
        self.prompt = "maestro> "

    def preloop(self):
        cmd.Cmd.preloop(self)
        readline.set_completer_delims(' ')

    def default(self, line):
        words = shlex.split(line)
        if len(words) > 0:
            res = self.session.api_request(words[0], tuple(words[1:]))
            if res is not None and res != '':
                pprint.pprint(res)
        return False

    def completedefault(self, text, line, begidx, endidx):
        words = shlex.split(line[:begidx])
        clas, func = words[0].split('.')
        if len(words) > 1 or \
           func.startswith('get_by_') or \
           func == 'get_all':
            return []
        uuids = self.session.api_request('%s.get_all' % clas, ())
        return [u + " " for u in uuids if u.startswith(text)]

    def emptyline(self):
        pass

    def do_EOF(self, line):
        print
        sys.exit(0)


def main(argv=None):
    '''Command line options.'''
    program_name = os.path.basename(sys.argv[0])
    program_version = maestro.version.__version__
 
    program_version_string = '%%prog %s' % (program_version)
    #program_usage = '''usage: spam two eggs''' # optional - will be autogenerated by optparse
    program_longdesc = '''''' # optional - give further explanation about what the program does
    program_license = "Copyright (c) 2015 InWorldz Inc. All Rights Reserved. Released under the Apache 2.0 License"

    if argv is None:
        argv = sys.argv[1:]
    try:
        # setup option parser
        parser = OptionParser(version=program_version_string, epilog=program_longdesc, description=program_license)
        
        parser.add_option("-p", "--password", dest="password", help="The password to use when connecting to the remote agent [default: %default]")
        parser.add_option("-u", "--username", dest="username", help="The username to use when connecting [default: %default]")
        parser.add_option("-i", "--ipaddress", dest="ipaddress", help="The hostname or ipaddress to establish a connection to [default: %default]")
        parser.add_option("-s", "--script", dest="script", help="An option script to run. [default: %default]")        
        parser.add_option("-v", "--verbose", dest="verbose", action="count", help="set verbosity level [default: %default]")
        
        # set defaults
        parser.set_defaults(password="", username="", ipaddress="127.0.0.1", verbose=1, script=None)
        
        # process options
        (opts, args) = parser.parse_args(argv)
        
        if opts.verbose > 0:
            print("verbosity level = %d" % opts.verbose)
            
        username = opts.username
        if (username == ""):
            username = raw_input("Username: ")
        password = opts.password
        if ((password == "") or (opts.username == "")):
            import getpass
            password = getpass.getpass("Password: ")    
          
        url = "http://%s:12089" % opts.ipaddress
        session = maestro.rpcclient.Session(url)
        session.api.login_with_password(username, password)
        
        # Make some shorthand Symbols
        RegionHost = session.api.RegionHost
        Region = session.api.Region
        Estate = session.api.Estate
        User = session.api.User
        ApertureService = session.api.ApertureService
        UserService = session.api.UserService
        MessagingService = session.api.MessagingService
        Memory = session.api.Memory
        Disk = session.api.Disk
        Cpu = session.api.Cpu
        Process = session.api.Process
        Session = session.api.session
        
        syms = globals().copy()
        syms.update(locals())
        shell = code.InteractiveConsole(syms)
        
        if opts.verbose > 0:
            print("The active session ref is at session._session")
            print("Get the current RegionHost ref with Session.get_this_host(session._session)\n\n")
                                
        if (opts.script == None):
            shell.interact()
        else:
            with open(os.path.normpath(opts.script)) as f:
                for line in iter(f):
                    shell.push(line)          

#        Shell(session).cmdloop('Welcome to the Inworldz Maestro shell. (Try "Region.get_all")')        
        session.api.session.logout()
        
    except Exception, e:
        indent = len(program_name) * " "
        sys.stderr.write(program_name + ": " + repr(e) + "\n")
        sys.stderr.write(indent + "  for help use --help")
        return 2        
    
if __name__ == "__main__":
    if DEBUG:
        sys.argv.append("-h")
        
    if TESTRUN:
        import doctest
        doctest.testmod()
        
    if PROFILE:
        import cProfile
        import pstats
        profile_filename = '_profile.txt'
        cProfile.run('main()', profile_filename)
        statsfile = open("profile_stats.txt", "wb")
        p = pstats.Stats(profile_filename, stream=statsfile)
        stats = p.strip_dirs().sort_stats('cumulative')
        stats.print_stats()
        statsfile.close()
        sys.exit(0)

    sys.exit(main())   
